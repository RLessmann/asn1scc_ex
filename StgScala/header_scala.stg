group scala_header;

rtlModuleName() ::= ""

indentation(sStatement) ::=<<
    <sStatement>
>>

PrintSpecificationFile(sFileNameWithNoExtUpperCase, sPackageName, arrsIncludedModules, arrsTypeAssignments, arrsValueAssignments, arrsPrototypes, arrsUtilityDefines, bHasEncodings, bXer) ::= <<
/*
Code automatically generated by asn1scc tool
*/
package asn1src

import asn1scala._
import stainless.lang._
import stainless.annotation._

<arrsTypeAssignments:{tas|<tas> // header:19 }; separator="\n">

<arrsValueAssignments:{vas|<vas> // header:21 }; separator="\n"> 

<arrsPrototypes:{proto|<proto> // header:23 }; separator="\n"> 
>>

Define_TAS(sTypeDefinition, arrsProcs) ::= <<
<sTypeDefinition>

<arrsProcs; separator="\n\n">
>>

PrintValueAssignment(sName, sTypeDecl, sValue) ::= << >>

/*
Scala TYPES 
*/

Declare_Integer() ::="Int"
Declare_PosInteger() ::="UInt"
Declare_IntegerNoRTL() ::="Int"
Declare_PosIntegerNoRTL() ::="UInt"

Declare_Boolean() ::= "Boolean"
Declare_Real() ::= "Float"

Declare_Int8() ::="Byte"
Declare_UInt8() ::="UByte"
Declare_Int16() ::="Short"
Declare_UInt16() ::="UShort"
Declare_Int32() ::="Int"
Declare_UInt32() ::="UInt"
Declare_Int64() ::="Long"
Declare_UInt64() ::="ULong"

Declare_Real32() ::= "Float"
Declare_Real64() ::= "Double"

Declare_BooleanNoRTL() ::= "BooleanNoRTL"
Declare_RealNoRTL() ::= "RealNoRTL"


Declare_Null() ::= "null"
Declare_NullNoRTL() ::= "nullNoRTL"
Declare_ObjectIdentifier() ::= "Asn1ObjectIdentifier"
Declare_ObjectIdentifierNoRTL() ::= "Asn1ObjectIdentifier"

Declare_Asn1LocalTime                 	()::= "Asn1LocalTime"
Declare_Asn1UtcTime                   	()::= "Asn1UtcTime"
Declare_Asn1LocalTimeWithTimeZone     	()::= "Asn1TimeWithTimeZone"
Declare_Asn1Date                      	()::= "Asn1Date"
Declare_Asn1Date_LocalTime            	()::= "Asn1DateLocalTime"
Declare_Asn1Date_UtcTime              	()::= "Asn1DateUtcTime"
Declare_Asn1Date_LocalTimeWithTimeZone	()::= "Asn1DateTimeWithTimeZone"

Declare_Asn1LocalTimeNoRTL                 	()::= "Asn1LocalTime"
Declare_Asn1UtcTimeNoRTL                   	()::= "Asn1UtcTime"
Declare_Asn1LocalTimeWithTimeZoneNoRTL     	()::= "Asn1TimeWithTimeZone"
Declare_Asn1DateNoRTL                      	()::= "Asn1Date"
Declare_Asn1Date_LocalTimeNoRTL            	()::= "Asn1DateLocalTime"
Declare_Asn1Date_UtcTimeNoRTL              	()::= "Asn1DateUtcTime"
Declare_Asn1Date_LocalTimeWithTimeZoneNoRTL	()::= "Asn1DateTimeWithTimeZone"


Define_SubType(sTypeDefinitionName, soParentTypePackage, sParentType, soNewRange, soExtraDefs) ::= <<
type <sTypeDefinitionName> = <sParentType> // header_scala:83
<soExtraDefs>
>>





/******************************************************************************************************************************/
/***********************************       NEW TYPE DEFINITIONS    ************************************************************/
/******************************************************************************************************************************/

/***********************************       ENUMERATED    ************************************************************/

Define_new_enumerated_item(sName, nValue) ::= "<sName> = <nValue>"

Define_new_enumerated_item_macro(td/*:FE_EnumeratedTypeDefinition*/, sAsn1Name, sCName) ::= "#define <td.typeName>_<sAsn1Name> <sCName> // header:101"

Define_new_enumerated(td/*:FE_EnumeratedTypeDefinition*/, arrsEnumNames, arrsEnumNamesAndValues, nIndexMax, arrsResolvingMacros) ::= <<
typedef enum {
    <arrsEnumNamesAndValues:{it|<it>}; separator=",\n">
} <td.typeName>;

// please use the following macros to avoid breaking code.
<arrsResolvingMacros; separator="\n">
>>



Define_subType_enumerated(td/*:FE_EnumeratedTypeDefinition*/, prTd/*:FE_EnumeratedTypeDefinition*/, soParentTypePackage) ::= <<
typedef <prTd.typeName> <td.typeName>;
>>

/***********************************       STRING    ************************************************************/

Define_new_ia5string(td/*:FE_StringTypeDefinition*/, nMin, nMax, nCMax, arrnAlphaChars) ::= <<
typedef char <td.typeName>[<nCMax>];
>>

Define_subType_ia5string(td/*:FE_StringTypeDefinition*/, prTd/*:FE_StringTypeDefinition*/, soParentTypePackage) ::= <<
typedef <prTd.typeName> <td.typeName>;
>>

/***********************************       OCTET STRING    ************************************************************/

Define_new_octet_string(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize) ::= <<
type <td.typeName> = Array[Byte]
>>

Define_subType_octet_string(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize) ::= <<
typedef <prTd.typeName> <td.typeName>;
>>

/***********************************       BIT STRING    ************************************************************/

Define_new_bit_string_named_bit(td/*:FE_SizeableTypeDefinition*/, sTargetLangBitName, sHexValue, sComment) ::= <<
#define <td.typeName>_<sTargetLangBitName> 0x<sHexValue>  /*<sComment>*/ // header:141
>>

Define_new_bit_string(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize, nMaxOctets, arrsNamedBits) ::= <<
<arrsNamedBits:{it|<it>}; separator="\n">

typedef struct {
<if(!bFixedSize)>
    int nCount; /*Number of bits in the array. Max value is : <nMax> */

<endif>    
    byte arr[<nMaxOctets>];
} <td.typeName>;
>>

Define_subType_bit_string(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize) ::= <<
typedef <prTd.typeName> <td.typeName>;
>>

/***********************************       SEQUENCE OF    ************************************************************/


Define_new_sequence_of(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize, sChildType, soChildDefintion) ::= <<

<soChildDefintion>

typedef struct {
<if(!bFixedSize)>
    int nCount; 

<endif>    
    <sChildType> arr[<nMax>];
} <td.typeName>;
>>



Define_subType_sequence_of(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize, soChildDefintion) ::= <<

<soChildDefintion>

typedef <prTd.typeName> <td.typeName>;
>>


/***********************************       SEQUENCE     ************************************************************/

Define_new_sequence_child_bit(sName) ::= "unsigned long <sName>:1; // header_scala:199"
Define_new_sequence_child(sName, sType) ::= "<sName>: <sType>"

Define_new_sequence_save_pos_child(td/*:FE_SequenceTypeDefinition*/, sName, nMaxBytesInACN) ::= "BitStream <sName>;"

Define_new_sequence(td/*:FE_SequenceTypeDefinition*/, arrsChildren, arrsOptionalChildren, arrsChildldrenDefintions, arrsNullFieldsSavePos) ::= <<
/*-- <td.typeName> --------------------------------------------*/
<arrsChildldrenDefintions; separator= "\n">
<if (arrsNullFieldsSavePos)>
typedef struct {
    <arrsNullFieldsSavePos; separator="\n">
} <td.extention_function_potisions>;

<endif>
<if (arrsOptionalChildren)>
typedef struct {
    <arrsOptionalChildren; separator="\n">
} <td.exist>;

<endif>
case class <td.typeName> (
    <arrsChildren; separator=",\n">
    <if (arrsOptionalChildren)>
    <td.exist> exist;
    <endif>
)
>>

Define_subType_sequence(td/*:FE_SequenceTypeDefinition*/, prTd/*:FE_SequenceTypeDefinition*/, soParentTypePackage, arrsOptionalChildren) ::= <<
typedef <prTd.typeName> <td.typeName>;
<if (arrsNullFieldsSavePos)>
typedef <prTd.extention_function_potisions> <td.extention_function_potisions>;

<endif>
>>

/***********************************       CHOICE    ************************************************************/


Define_new_choice_child(sName, sType, sPresent) ::=<<
<sName>: <sType>
>>

Define_new_choice(td/*:FE_ChoiceTypeDefinition*/, sChoiceIDForNone, sFirstChildNamePresent, arrsChildren, arrsPresent, nIndexMax, arrsChildldrenDefintions) ::= <<
/*-- <td.typeName> --------------------------------------------*/
<arrsChildldrenDefintions; separator= "\n">

typedef enum {
    <sChoiceIDForNone>,
    <arrsPresent:{ch|<ch>}; separator=",\n"> 
} <td.selection>;

typedef union {
    <arrsChildren:{ch|<ch>}; separator="\n">
} <td.union_name>; 

typedef struct {
    <td.selection> kind;
    
    <td.union_name> u; 
} <td.typeName>;
>>

Define_subType_choice(td/*:FE_ChoiceTypeDefinition*/, prTd/*:FE_ChoiceTypeDefinition*/, soParentTypePackage) ::= <<
typedef <prTd.typeName> <td.typeName>;
>>

Define_SubType_int_range(soParentTypePackage, sParentType, noMin, noMax) ::= <<
>>
