group scala_header;

rtlModuleName() ::= ""

indentation(sStatement) ::=<<
    <sStatement>
>>

PrintSpecificationFile(sFileNameWithNoExtUpperCase, sPackageName, arrsIncludedModules, arrsTypeAssignments, arrsValueAssignments, arrsPrototypes, arrsUtilityDefines, bHasEncodings, bXer) ::= <<
/*
Code automatically generated by asn1scc tool
*/
package asn1src

import asn1scala._
import stainless.lang._
import stainless.annotation._

<arrsTypeAssignments:{tas|<tas> // header:19 }; separator="\n">

<arrsValueAssignments:{vas|<vas> // header:21 }; separator="\n"> 

<arrsPrototypes:{proto|<proto> // header:23 }; separator="\n"> 
>>

Define_TAS(sTypeDefinition, arrsProcs) ::= <<
<sTypeDefinition>

<arrsProcs; separator="\n\n">
>>

PrintValueAssignment(sName, sTypeDecl, sValue) ::= <<
// @inline @cCode.inline val <sName>: <sTypeDecl> = <sValue> // defined in body
>>

/*
Scala TYPES 
*/

Declare_Integer() ::="Long"
Declare_PosInteger() ::="ULong"
Declare_IntegerNoRTL() ::="LongNoRTL"
Declare_PosIntegerNoRTL() ::="ULongNoRTL"

Declare_Boolean() ::= "Boolean"
Declare_Real() ::= "Float"

Declare_Int8() ::="Byte"
Declare_UInt8() ::="UByte"
Declare_Int16() ::="Short"
Declare_UInt16() ::="UShort"
Declare_Int32() ::="Int"
Declare_UInt32() ::="UInt"
Declare_Int64() ::="Long"
Declare_UInt64() ::="ULong"

Declare_Real32() ::= "Float"
Declare_Real64() ::= "Double"

Declare_BooleanNoRTL() ::= "BooleanNoRTL"
Declare_RealNoRTL() ::= "RealNoRTL"


Declare_Null() ::= "NullType"
Declare_NullNoRTL() ::= "NullType"
Declare_ObjectIdentifier() ::= "Asn1ObjectIdentifier"
Declare_ObjectIdentifierNoRTL() ::= "Asn1ObjectIdentifier"

Declare_Asn1LocalTime                 	()::= "Asn1LocalTime"
Declare_Asn1UtcTime                   	()::= "Asn1UtcTime"
Declare_Asn1LocalTimeWithTimeZone     	()::= "Asn1TimeWithTimeZone"
Declare_Asn1Date                      	()::= "Asn1Date"
Declare_Asn1Date_LocalTime            	()::= "Asn1DateLocalTime"
Declare_Asn1Date_UtcTime              	()::= "Asn1DateUtcTime"
Declare_Asn1Date_LocalTimeWithTimeZone	()::= "Asn1DateTimeWithTimeZone"

Declare_Asn1LocalTimeNoRTL                 	()::= "Asn1LocalTime"
Declare_Asn1UtcTimeNoRTL                   	()::= "Asn1UtcTime"
Declare_Asn1LocalTimeWithTimeZoneNoRTL     	()::= "Asn1TimeWithTimeZone"
Declare_Asn1DateNoRTL                      	()::= "Asn1Date"
Declare_Asn1Date_LocalTimeNoRTL            	()::= "Asn1DateLocalTime"
Declare_Asn1Date_UtcTimeNoRTL              	()::= "Asn1DateUtcTime"
Declare_Asn1Date_LocalTimeWithTimeZoneNoRTL	()::= "Asn1DateTimeWithTimeZone"


Define_SubType(sTypeDefinitionName, soParentTypePackage, sParentType, soNewRange, soExtraDefs) ::= <<
type <sTypeDefinitionName> = <sParentType> // header_scala:83
<soExtraDefs>
>>





/******************************************************************************************************************************/
/***********************************       NEW TYPE DEFINITIONS    ************************************************************/
/******************************************************************************************************************************/

/***********************************       ENUMERATED    ************************************************************/

Define_new_enumerated_item(td/*:FE_EnumeratedTypeDefinition*/, sName, nValue) ::= <<
case <sName> extends <td.typeName>(<nValue>) // header:102
>>

Define_new_enumerated_item_macro(td/*:FE_EnumeratedTypeDefinition*/, sAsn1Name, sCName) ::= <<
// type <sCName> = <td.typeName>.<sAsn1Name> // header_106
>>

Define_new_enumerated(td/*:FE_EnumeratedTypeDefinition*/, arrsEnumNames, arrsEnumNamesAndValues, nIndexMax, arrsResolvingMacros) ::= <<
enum <td.typeName>(val i: Int): 
    <arrsEnumNamesAndValues:{it|<it>}; separator="\n">

// please use the following macros to avoid breaking code.
<arrsResolvingMacros; separator="\n">
>>



Define_subType_enumerated(td/*:FE_EnumeratedTypeDefinition*/, prTd/*:FE_EnumeratedTypeDefinition*/, soParentTypePackage) ::= <<
typedef <prTd.typeName> <td.typeName> // header:120
>>

/***********************************       STRING    ************************************************************/

Define_new_ia5string(td/*:FE_StringTypeDefinition*/, nMin, nMax, nCMax, arrnAlphaChars) ::= <<
type <td.typeName> = Array[Byte] // max size in C was [<nCMax>] header:126
>>

Define_subType_ia5string(td/*:FE_StringTypeDefinition*/, prTd/*:FE_StringTypeDefinition*/, soParentTypePackage) ::= <<
typedef <prTd.typeName> <td.typeName> // header:130
>>

/***********************************       OCTET STRING    ************************************************************/

Define_new_octet_string(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize) ::= <<
type <td.typeName> = Array[Byte] // header:136
>>

Define_subType_octet_string(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize) ::= <<
typedef <prTd.typeName> <td.typeName> // header:140
>>

/***********************************       BIT STRING    ************************************************************/

Define_new_bit_string_named_bit(td/*:FE_SizeableTypeDefinition*/, sTargetLangBitName, sHexValue, sComment) ::= <<
#define <td.typeName>_<sTargetLangBitName> 0x<sHexValue>  /*<sComment>*/ // header:141
>>

Define_new_bit_string(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize, nMaxOctets, arrsNamedBits) ::= <<
<arrsNamedBits:{it|<it>}; separator="\n">

<if(!bFixedSize)>
/*nCount equals to Number of bits in the array. Max value is : <nMax> */

<endif>
case class <td.typeName>(<if(!bFixedSize)>var nCount: Long, <endif>var arr: Array[Byte]) // header:155
{
    require(arr.length == <nMaxOctets>)
}
>>

Define_subType_bit_string(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize) ::= <<
typedef <prTd.typeName> <td.typeName> // header:162
>>

/***********************************       SEQUENCE OF    ************************************************************/


Define_new_sequence_of(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize, sChildType, soChildDefintion) ::= <<

<soChildDefintion>

case class <td.typeName> (<if(!bFixedSize)>var nCount: Int, <endif>arr: Array[<sChildType>]) // header:172  
{
    require(arr.length == <nMax>)
}
>>

Define_subType_sequence_of(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize, soChildDefintion) ::= <<

<soChildDefintion>

typedef <prTd.typeName> <td.typeName> // header:182
>>


/***********************************       SEQUENCE     ************************************************************/

Define_new_sequence_child_bit(sName) ::= "<sName>: Boolean // header:188"

Define_new_sequence_child(sName, sType) ::= "<sName>: <sType>"

Define_new_sequence_save_pos_child(td/*:FE_SequenceTypeDefinition*/, sName, nMaxBytesInACN) ::= "BitStream <sName>;"

Define_new_sequence(td/*:FE_SequenceTypeDefinition*/, arrsChildren, arrsOptionalChildren, arrsChildldrenDefintions, arrsNullFieldsSavePos) ::= <<
/*-- <td.typeName> --------------------------------------------*/
<arrsChildldrenDefintions; separator= "\n">
<if (arrsNullFieldsSavePos)>
case class <td.extention_function_potisions> (
    <arrsNullFieldsSavePos; separator="\n">
)

<endif>
<if (arrsOptionalChildren)>
case class <td.exist> ( // header:204
    <arrsOptionalChildren:{ch|var <ch>}; separator=", \n">
)

<endif>
case class <td.typeName> ( // header:209
<if (arrsOptionalChildren)>
    var exist: <td.exist>,

<endif>
    <arrsChildren:{ch|var <ch>}; separator=", \n">
)

>>

Define_subType_sequence(td/*:FE_SequenceTypeDefinition*/, prTd/*:FE_SequenceTypeDefinition*/, soParentTypePackage, arrsOptionalChildren) ::= <<
type <td.typeName> = <prTd.typeName>  // header:220
<if (arrsNullFieldsSavePos)>
type <td.extention_function_potisions> = <prTd.extention_function_potisions> // header:222
<endif>
>>

/***********************************       CHOICE    ************************************************************/


Define_new_choice_child(sName, sType, sPresent) ::=<<
<sName>: <sType> /*header:230*/
>>

Define_new_choice(td/*:FE_ChoiceTypeDefinition*/, sChoiceIDForNone, sFirstChildNamePresent, arrsChildren, arrsPresent, arrsCombined, nIndexMax, arrsChildldrenDefintions) ::= <<
/*-- <td.typeName> --------------------------------------------*/
<arrsChildldrenDefintions; separator= "\n">

enum <td.typeName>:
    case <sChoiceIDForNone>()
    <arrsCombined:{ch|case <ch>}; separator="\n">
>>

Define_subType_choice(td/*:FE_ChoiceTypeDefinition*/, prTd/*:FE_ChoiceTypeDefinition*/, soParentTypePackage) ::= <<
typedef <prTd.typeName> <td.typeName> // header:243
>>

Define_SubType_int_range(soParentTypePackage, sParentType, noMin, noMax) ::= <<
>>
