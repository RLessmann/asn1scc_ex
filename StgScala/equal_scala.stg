group c_equal;


JoinItems(sPart, soNestedPart) ::= <<
// equal_scala.stg : 5
<sPart>
<if(soNestedPart)>
if ret then
    <soNestedPart>
<endif>
>>

JoinItems2_ret(sPart, sNestedPart) ::= <<
// equal_scala.stg : 14
<sPart>
if (ret) {
    <sNestedPart>
}
>>

JoinItems2_ret_result(sPart, sNestedPart) ::= <<
// equal_scala.stg : 22
<sPart>
if (ret) {
    <sNestedPart>
}
>>



/*
*****************************************************************************************
 E Q U A L      F U N C T I O N S
*****************************************************************************************
*/
PrintEqualDefintionPrimitive(sFuncName, sTypeDefName) ::= <<
>>

PrintEqualDefintionComposite(sFuncName, sTypeDefName) ::= <<
>>

PrintEqualPrimitive(sFuncName, sTypeDefName, sContent) ::= <<
// equal_scala.stg : 47
def <sFuncName>(val1: <sTypeDefName>, val2: <sTypeDefName>): Boolean =
{
    return <sContent>
}
>>



PrintEqualComposite(sFuncName, sTypeDefName, sContent, arrsLocalVars) ::= <<
// equal_scala.stg : 57
def <sFuncName>(pVal1: <sTypeDefName>, pVal2: <sTypeDefName>): Boolean =
{
    var ret: Boolean = true
    <arrsLocalVars; separator="\n">

    <sContent>
    return ret
}
>>

equalTypeAssignment_def(sVarName1, sVarName2, sStar, sFuncName, sTypeDefName) ::= <<
// equal_scala.stg : 69
>>

equalTypeAssignment(sVarName1, sVarName2, sStar, sFuncName, sTypeDefName, sContent, arrsLocalVars, bExpression, bUnreferenced) ::= <<
// equal_scala.stg : 74
def <sFuncName>(<sVarName1>: <sTypeDefName>, <sVarName2>: <sTypeDefName>): Boolean =
{
    <if(bUnreferenced)>
    // equal_scala.stg:77
    <sVarName1>
    <sVarName2>
    <endif>
    
    <if(bExpression)>
    // equal_scala.stg:83
    return <sContent>

    <else>
    // equal_scala.stg:87
    var ret: Boolean = true
    <arrsLocalVars; separator="\n">

    <sContent>
    return ret

    <endif>
}
>>


isEqual_Primitive(p1, p2) ::= "<p1> == <p2> /* equal_scala.stg:97 */"

isEqual_String(p1, p2) ::= "<p1>.sameElements(<p2>) /* equal_scala.stg:99 */"


isEqual_Integer(p1, p2) /*nogen*/::= "ret = (<p1> == <p2>); /* equal_scala.stg:102 */"

isEqual_Enumerated(p1, p2) /*nogen*/::= "<isEqual_Integer(p1=p1,p2=p2)> /* equal_scala.stg:104 */"


isEqual_Boolean(p1, p2) /*nogen*/::= "ret = ( (<p1> && <p2>) || (!<p1> && !<p2>)); /* equal_scala.stg:107 */"

isEqual_Real(p1, p2) ::= "<p1> == <p2> /* equal_scala.stg:109 */"

isEqual_IA5String(p1, p2) /*nogen*/::= "ret = (strcmp(<p1>, <p2>) ==0); /* equal_scala.stg:111 */"

isEqual_NumericString(p1, p2) /*nogen*/::= "<isEqual_IA5String(p1=p1, p2=p2)> /* equal_scala.stg:113 */"
isEqual_NullType()/*nogen*/ ::= "ret = true; /* equal_scala.stg:114 */"

isEqual_BitString(p1,p2,bIsFixedSize, nFixedSize) ::= <<
<if(!bIsFixedSize)>
    (<p1>nCount == <p2>nCount) && 
    (<p1>arr.sameElements(<p2>arr)) && 
    (if <p1>nCount % 8 > 0 then (<p1>arr(<p1>nCount.toInt/8) \>> (8-<p1>nCount % 8) == <p2>arr(<p1>nCount.toInt/8)\>>(8-<p1>nCount % 8) ) else true)

<else>
    (<p1>arr.sameElements(<p2>arr)) &&
    (if (<nFixedSize> % 8) > 0 then (<p1>arr(<nFixedSize>/8)\>>(8-<nFixedSize> % 8) == <p2>arr(<nFixedSize>/8)\>>(8-<nFixedSize> % 8) ) else true)

<endif>
>>



isEqual_OctetString(p1,p2, bIsFixedSize, nFixedSize) ::= <<
<if(!bIsFixedSize)>
    (<p1>nCount == <p2>nCount) && (<p1>arr.sameElements(<p2>arr))
<else>
    <p1>arr.sameElements(<p2>arr)
<endif>    
>>

isObjectIdentifier_equal(p1, p2) ::= <<
// equal_scala.stg : 142
ObjectIdentifier_equal(<p1>, <p2>)
>>



isEqual_Choice_Child(choiceTypeDefName, sCid, sInnerStatement) ::= <<
// equal_scala.stg : 149
case (<choiceTypeDefName>.<sCid>(pVal1_e), <choiceTypeDefName>.<sCid>(pVal2_e)) =>
    <sInnerStatement>
>>

isEqual_Choice(p1,p2, sAccess, arrsChildren) ::= <<
// equal_scala.stg : 156
ret = <p1><sAccess>ordinal == <p2><sAccess>ordinal // equal:145
// equal:146
(<p1>, <p2>) match {
    <arrsChildren: {ch|<ch>}; separator="\n">
    case (_, _) =>
        ret = false
}
>>

isEqual_Sequence_child(p1, p2, sAcc,  bIsOptional, sChName, soInnerStatement) ::= <<
// equal_scala.stg : 166
<if(bIsOptional)>
// equal_scala.stg : 167
ret = (<p1><sAcc>exist.<sChName> == <p2><sAcc>exist.<sChName>) // equal:168
<if(soInnerStatement)> // equal_scala.stg : 173
if (ret && <p1><sAcc>exist.<sChName>) then // equal_scala.stg : 174
    <soInnerStatement>

<endif>
<else>
<soInnerStatement> // equal_scala.stg : 179

<endif>
>>



isEqual_SequenceOf_var_size(p1,p2, sAcc, i, soInnerStatement) ::= <<
// equal_scala.stg : 187
ret = (<p1><sAcc>nCount == <p2><sAcc>nCount)
<if (soInnerStatement)>
<i> = 0
while ret && <i> \< <p1><sAcc>nCount do // equal:174
    <soInnerStatement>
    <i> += 1


<endif>
>>

isEqual_SequenceOf_fix_size(p1,p2, sAcc, i, nFixedSize, sInnerStatement) ::= <<
// equal_scala.stg : 199
for(<i> = 0; ret && <i> \< <nFixedSize>; <i>++) // equal:183
{
    <sInnerStatement>
}

>>

call_base_type_func(p1, p2, sFuncName) ::= "<sFuncName>(<p1>, <p2>)"

makeExpressionToStatement(sIsValidExp) ::= <<
// equal_scala.stg : 210
ret = <sIsValidExp>
>>


callChildEqualFunc(p1, p2,  sChildEqualFuncName) ::= <<
ret = <sChildEqualFuncName>(<p1>, <p2>) // equal_scala.stg : 211
>>