group scala_acn;

getStringSize(p) ::= "<p>.indexOf(0x00)"

getSizeableSize(p, sAcc) ::= "<p><sAcc>nCount // TODO acn:5"

EmitTypeAssignment_def_err_code(sErrCode, nErrValue, soErrorCodeComment) ::= <<
@inline @cCode.inline val <sErrCode>: Int = <nErrValue> /* <soErrorCodeComment> acn:8 */ 
>>

EmitAcnParameter(sName, sType) ::= "<sType> <sName> /*TODO acn:11 */"


EmitTypeAssignment_primitive_def_encode(sVarName, sStar, sFuncName, sTypeDefName, arrsErrcodes, bEmptyEncodingSpace, nMaxBytesInACN, nMaxBitsInACN, arrsAcnPrms, soSparkAnnotations) ::= <<
<arrsErrcodes; separator="\n">
@inline @cCode.inline val <sTypeDefName>_REQUIRED_BYTES_FOR_ACN_ENCODING = <nMaxBytesInACN> 
@inline @cCode.inline val <sTypeDefName>_REQUIRED_BITS_FOR_ACN_ENCODING = <nMaxBitsInACN> // acn:17
>>

EmitTypeAssignment_primitive_encode(sVarName, sStar, sFuncName, soIValidFuncName, sTypeDefName, arrsLocalVariables, sContent, soSparkAnnotations, sInitilialExp, arrsAcnPrms, arrsAcnParamNames, bEmptyEncodingSpace, bBsIsUnreferenced, bVarNameIsUnreferenced, soInitFuncName) ::= <<
def <sFuncName>(<if(bVarNameIsUnreferenced)>@annotation.unused <endif><sVarName>: <sTypeDefName>, <if(bBsIsUnreferenced)>@annotation.unused <endif>pBitStrm: BitStream, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    var ret: Either[ErrorCode, Int] = Right(0)

    <arrsLocalVariables:{lv|<lv>}; separator="\n">
    <if(soIValidFuncName)>
    if bCheckConstraints then 
        ret = <soIValidFuncName>(<sVarName>)
    if (ret.isRight) { // acn:43 - classical design (scala 2), sContent could be empty
        <sContent>
    }
    <else>
    <sContent>
    <endif>
     
    ret
}
>>

EmitTypeAssignment_primitive_def_decode(sVarName, sStar, sFuncName, sTypeDefName, arrsErrcodes, bEmptyEncodingSpace, nMaxBytesInACN, nMaxBitsInACN, arrsAcnPrms, soSparkAnnotations) ::= <<
<arrsErrcodes; separator="\n">
>>

EmitTypeAssignment_primitive_decode(sVarName, sStar, sFuncName, soIValidFuncName, sTypeDefName, arrsLocalVariables, sContent, soSparkAnnotations, sInitilialExp, arrsAcnPrms, arrsAcnParamNames, bEmptyEncodingSpace, bBsIsUnreferenced, bVarNameIsUnreferenced, soInitFuncName) ::= <<
def <sFuncName>(<if(bBsIsUnreferenced)>@annotation.unused <endif>pBitStrm: BitStream): Either[ErrorCode, <sTypeDefName>] = // acn:45
{   
    var <sVarName>: <sTypeDefName> = <soInitFuncName>()
    var ret: Either[ErrorCode, <sTypeDefName>] = Right(<sVarName>)

    <arrsLocalVariables:{lv|<lv>}; separator="\n">

    <sContent>

    if ret.isRight then
        ret = Right(<sVarName>)
    <if(soIValidFuncName)>    
    ret match
        case Left(x) =>
            assert(false) // no left should reach this point
        case Right(x) =>
            <soIValidFuncName>(x) match
            case Left(l) => 
                return Left(l)
            case _ =>
    <endif>
    ret
}
>>

A(sErrCode) /*nogen*/ ::= ""

MF(soMF) ::= /*nogen*/ <<
<if(soMF)>
if (ret.isRight) {
    <p> = <soMF>_decode(<p>)
}
<endif>
>>
 
loopFixedItem (i, fixedSize,  sInternalItem)::= /*nogen*/ <<
<i> = 0
while ret.isRight && <i> \< <fixedSize>.asInstanceOf[Int] do
    <sInternalItem>
    <i> += 1
>>

alignToNext_encode(sMainBody, sAligmentValue, nAligmentValue) ::= <<
Acn_AlignTo<sAligmentValue>(pBitStrm, true) // acn:86
<sMainBody>
>>

alignToNext_decode(sMainBody, sAligmentValue, nAligmentValue) ::= <<
Acn_AlignTo<sAligmentValue>(pBitStrm, false) // acn:91
<sMainBody>
>>

PositiveInteger_ConstSize_encode(p, sSsuffix, sErrCode, nFixedSize, soMF, soMFM, nUperMin, nUperMax) ::= "Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, <if(soMF)><soMF>_encode(<p>)<else><p><endif>, <nFixedSize>) // acn:95"
PositiveInteger_ConstSize_decode(p, sSsuffix, sErrCode, nFixedSize, soMF, soMFM, nUperMin, nUperMax) ::= <<
Acn_Dec_Int_PositiveInteger_ConstSize<sSsuffix>(pBitStrm, <nFixedSize>) match // acn:97
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
<MF(soMF)>
>>

PositiveInteger_ConstSize_8_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, <if(soMF)><soMF>_encode(<p>)<else><p><endif>) // acn:103"
PositiveInteger_ConstSize_8_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
Acn_Dec_Int_PositiveInteger_ConstSize_8<sSsuffix>(pBitStrm) match // acn:105
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
<MF(soMF)>
>>

PositiveInteger_ConstSize_big_endian_16_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_16(pBitStrm, <if(soMF)><soMF>_encode(<p>)<else><p><endif>) // acn:111"
PositiveInteger_ConstSize_big_endian_16_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_16<sSsuffix>(pBitStrm) match // acn:113
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
<MF(soMF)>
>>

PositiveInteger_ConstSize_big_endian_32_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, <if(soMF)><soMF>_encode(<p>)<else><p><endif>) // acn:119"
PositiveInteger_ConstSize_big_endian_32_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32<sSsuffix>(pBitStrm) match // acn:121
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
<MF(soMF)>
>>

PositiveInteger_ConstSize_big_endian_64_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_64(pBitStrm, <if(soMF)><soMF>_encode(<p>)<else><p><endif>) // acn:127"
PositiveInteger_ConstSize_big_endian_64_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_64<sSsuffix>(pBitStrm) match // acn:129
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x 
<MF(soMF)>
>>

PositiveInteger_ConstSize_little_endian_16_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_16(pBitStrm, <if(soMF)><soMF>_encode(<p>)<else><p><endif>) // acn:135"
PositiveInteger_ConstSize_little_endian_16_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_16<sSsuffix>(pBitStrm) match // acn:137
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x 
<MF(soMF)>
>>

PositiveInteger_ConstSize_little_endian_32_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, <if(soMF)><soMF>_encode(<p>)<else><p><endif>) // acn:143"
PositiveInteger_ConstSize_little_endian_32_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32<sSsuffix>(pBitStrm) match // acn:145
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
<MF(soMF)>
>>

PositiveInteger_ConstSize_little_endian_64_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_64(pBitStrm, <if(soMF)><soMF>_encode(<p>)<else><p><endif>) // acn:151"
PositiveInteger_ConstSize_little_endian_64_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_64<sSsuffix>(pBitStrm) match // acn:153
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
<MF(soMF)>
>>

PositiveInteger_VarSize_LengthEmbedded_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin) ::= "Acn_Enc_Int_PositiveInteger_VarSize_LengthEmbedded(pBitStrm, <if(soMF)><soMF>_encode(<p>)<else><p><endif>) // acn:159"
PositiveInteger_VarSize_LengthEmbedded_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin) ::= <<
Acn_Dec_Int_PositiveInteger_VarSize_LengthEmbedded<sSsuffix>(pBitStrm) match // acn:161
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
<MF(soMF)>
>>

TwosComplement_ConstSize_encode(p, sSsuffix, sErrCode, soMF, soMFM, nFixedSize, nUperMin, nUperMax) ::= "Acn_Enc_Int_TwosComplement_ConstSize(pBitStrm, <if(soMF)><soMF>_encode(<p>)<else><p><endif>, <nFixedSize>) // acn:167"
TwosComplement_ConstSize_decode(p, sSsuffix, sErrCode, soMF, soMFM, nFixedSize, nUperMin, nUperMax) ::= <<
Acn_Dec_Int_TwosComplement_ConstSize<sSsuffix>(pBitStrm, <nFixedSize>) match // acn:169
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
<MF(soMF)>
>>

TwosComplement_ConstSize_8_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "Acn_Enc_Int_TwosComplement_ConstSize_8(pBitStrm, <if(soMF)><soMF>_encode(<p>)<else><p><endif>) // acn:165"
TwosComplement_ConstSize_8_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
Acn_Dec_Int_TwosComplement_ConstSize_8<sSsuffix>(pBitStrm) match // acn:167
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
<MF(soMF)>
>>

TwosComplement_ConstSize_big_endian_16_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "Acn_Enc_Int_TwosComplement_ConstSize_big_endian_16(pBitStrm, <if(soMF)><soMF>_encode(<p>)<else><p><endif>) // acn:183"
TwosComplement_ConstSize_big_endian_16_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
Acn_Dec_Int_TwosComplement_ConstSize_big_endian_16<sSsuffix>(pBitStrm) match // acn:185
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
>>

TwosComplement_ConstSize_big_endian_32_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "Acn_Enc_Int_TwosComplement_ConstSize_big_endian_32(pBitStrm, <if(soMF)><soMF>_encode(<p>)<else><p><endif>) // acn:190"
TwosComplement_ConstSize_big_endian_32_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
Acn_Dec_Int_TwosComplement_ConstSize_big_endian_32<sSsuffix>(pBitStrm) match // acn:192
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
<MF(soMF)>
>>

TwosComplement_ConstSize_big_endian_64_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "Acn_Enc_Int_TwosComplement_ConstSize_big_endian_64(pBitStrm, <if(soMF)><soMF>_encode(<p>)<else><p><endif>) // acn:198"
TwosComplement_ConstSize_big_endian_64_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
Acn_Dec_Int_TwosComplement_ConstSize_big_endian_64<sSsuffix>(pBitStrm) match // acn:200
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
<MF(soMF)>
>>

TwosComplement_ConstSize_little_endian_16_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "Acn_Enc_Int_TwosComplement_ConstSize_little_endian_16(pBitStrm, <if(soMF)><soMF>_encode(<p>)<else><p><endif>) // acn:206"
TwosComplement_ConstSize_little_endian_16_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
Acn_Dec_Int_TwosComplement_ConstSize_little_endian_16<sSsuffix>(pBitStrm) match // acn:208
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
<MF(soMF)>
>>

TwosComplement_ConstSize_little_endian_32_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "Acn_Enc_Int_TwosComplement_ConstSize_little_endian_32(pBitStrm, <if(soMF)><soMF>_encode(<p>)<else><p><endif>) // acn:214"
TwosComplement_ConstSize_little_endian_32_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
Acn_Dec_Int_TwosComplement_ConstSize_little_endian_32<sSsuffix>(pBitStrm) match // acn:216
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
<MF(soMF)>
>>

TwosComplement_ConstSize_little_endian_64_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "Acn_Enc_Int_TwosComplement_ConstSize_little_endian_64(pBitStrm, <if(soMF)><soMF>_encode(<p>)<else><p><endif>) // acn:222"
TwosComplement_ConstSize_little_endian_64_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
Acn_Dec_Int_TwosComplement_ConstSize_little_endian_64<sSsuffix>(pBitStrm) // acn:224
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
<MF(soMF)>
>>

TwosComplement_VarSize_LengthEmbedded_encode(p, sSsuffix, sErrCode, soMF, soMFM) ::= "Acn_Enc_Int_TwosComplement_VarSize_LengthEmbedded(pBitStrm, <if(soMF)><soMF>_encode(<p>)<else><p><endif>) // acn:230"
TwosComplement_VarSize_LengthEmbedded_decode(p, sSsuffix, sErrCode, soMF, soMFM) ::= <<
Acn_Dec_Int_TwosComplement_VarSize_LengthEmbedded<sSsuffix>(pBitStrm) // acn:232
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
<MF(soMF)>
>>

BCD_ConstSize_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax, nNibbles) ::= "Acn_Enc_Int_BCD_ConstSize(pBitStrm, <if(soMF)><soMF>_encode(<p>)<else><p><endif>, <nNibbles>) // acn:238"
BCD_ConstSize_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax, nNibbles) ::= <<
Acn_Dec_Int_BCD_ConstSize<sSsuffix>(pBitStrm, <nNibbles>) match // acn:240
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
<MF(soMF)>
>>

BCD_VarSize_LengthEmbedded_encode(p, sSsuffix, sErrCode, soMF, soMFM) ::= "Acn_Enc_Int_BCD_VarSize_LengthEmbedded(pBitStrm, <if(soMF)><soMF>_encode(<p>)<else><p><endif>) // acn:246"
BCD_VarSize_LengthEmbedded_decode(p, sSsuffix, sErrCode, soMF, soMFM) ::= <<
Acn_Dec_Int_BCD_VarSize_LengthEmbedded<sSsuffix>(pBitStrm) // acn:248
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
<MF(soMF)>
>>

BCD_VarSize_NullTerminated_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "Acn_Enc_Int_BCD_VarSize_NullTerminated(pBitStrm, <if(soMF)><soMF>_encode(<p>)<else><p><endif>) // acn:254"
BCD_VarSize_NullTerminated_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
Acn_Dec_Int_BCD_VarSize_NullTerminated<sSsuffix>(pBitStrm) match // acn:256
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
<MF(soMF)>
>>

ASCII_ConstSize_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax, nSizeInBytes) ::= "Acn_Enc_SInt_ASCII_ConstSize(pBitStrm, <if(soMF)><soMF>_encode(<p>)<else><p><endif>, <nSizeInBytes>) // acn:262"
ASCII_ConstSize_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax, nSizeInBytes) ::= <<
Acn_Dec_SInt_ASCII_ConstSize<sSsuffix>(pBitStrm, <nSizeInBytes>) match // acn:264
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
<MF(soMF)>
>>

ASCII_VarSize_LengthEmbedded_encode(p, sSsuffix, sErrCode, soMF, soMFM) ::= "Acn_Enc_SInt_ASCII_VarSize_LengthEmbedded(pBitStrm, <if(soMF)><soMF>_encode(<p>)<else><p><endif>) // acn:270"
ASCII_VarSize_LengthEmbedded_decode(p, sSsuffix, sErrCode, soMF, soMFM) ::= <<
Acn_Dec_SInt_ASCII_VarSize_LengthEmbedded<sSsuffix>(pBitStrm) match // acn:272
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
<MF(soMF)>
>>

ASCII_VarSize_NullTerminated_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax, arruNullBytes) ::= <<
Acn_Enc_SInt_ASCII_VarSize_NullTerminated(pBitStrm, <if(soMF)><soMF>_encode(<p>)<else><p><endif>, (byte[]){<arruNullBytes; separator=", ">}, <arruNullBytes.Length>) // TODO acn:279
>>

ASCII_VarSize_NullTerminated_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax, arruNullBytes) ::= <<
Acn_Dec_SInt_ASCII_VarSize_NullTerminated<sSsuffix>(pBitStrm, (byte[]){<arruNullBytes; separator=", ">}, <arruNullBytes.Length>) match // TODO acn:283
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
<MF(soMF)>
>>

ASCII_UINT_ConstSize_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax, nSizeInBytes) ::= <<
Acn_Enc_UInt_ASCII_ConstSize(pBitStrm, <if(soMF)><soMF>_encode(<p>)<else><p><endif>, <nSizeInBytes>) // acn:290
>>

ASCII_UINT_ConstSize_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax, nSizeInBytes) ::= <<
Acn_Dec_UInt_ASCII_ConstSize<sSsuffix>(pBitStrm, <nSizeInBytes>) match // acn:294
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
<MF(soMF)>
>>

ASCII_UINT_VarSize_NullTerminated_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax, arruNullBytes) ::= <<
Acn_Enc_UInt_ASCII_VarSize_NullTerminated(pBitStrm, <if(soMF)><soMF>_encode(<p>)<else><p><endif>, (byte[]){<arruNullBytes; separator=", ">}, <arruNullBytes.Length>) // TODO acn:301
>>

ASCII_UINT_VarSize_NullTerminated_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax, arruNullBytes) ::= <<
Acn_Dec_UInt_ASCII_VarSize_NullTerminated<sSsuffix>(pBitStrm, <p>, (byte[]){<arruNullBytes; separator=", ">}, <arruNullBytes.Length>) match // TODO acn:305
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
<MF(soMF)>
>>

Real_32_big_endian_encode(p, sSuffix, sErrCode) ::= "Acn_Enc_Real_IEEE754_32_big_endian(pBitStrm, <p>.toFloat) // acn:311"
Real_32_big_endian_decode(p, sSuffix, sErrCode) ::= <<
Acn_Dec_Real_IEEE754_32_big_endian<sSuffix>(pBitStrm) match // acn:313
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
>>

Real_64_big_endian_encode(p, sErrCode) ::= "Acn_Enc_Real_IEEE754_64_big_endian(pBitStrm, <p>) // acn:318"
Real_64_big_endian_decode(p, sErrCode) ::= <<
Acn_Dec_Real_IEEE754_64_big_endian(pBitStrm) match // acn:320
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
>>

Real_32_little_endian_encode(p, sSuffix, sErrCode) ::= "Acn_Enc_Real_IEEE754_32_little_endian(pBitStrm, <p>) // acn:325"
Real_32_little_endian_decode(p, sSuffix, sErrCode) ::= <<
Acn_Dec_Real_IEEE754_32_little_endian<sSuffix>(pBitStrm) match // acn:327
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
>>

Real_64_little_endian_encode(p, sErrCode) ::= "Acn_Enc_Real_IEEE754_64_little_endian(pBitStrm, <p>) // acn:332"
Real_64_little_endian_decode(p, sErrCode) ::= <<
Acn_Dec_Real_IEEE754_64_little_endian(pBitStrm) match // acn:334
    case None => 
        return Left(<sErrCode>)
    case Some(x) => 
        <p> = x
>>


Boolean_encode(p, ptr, bEncValIsTrue, nSize, arruTrueValueAsByteArray, arruFalseValueAsByteArray, arrsBits, sErrCode) ::= <<
{
    var true_data: Array[UByte] = Array(<arruTrueValueAsByteArray:{b|0x<b;format="X2">.asInstanceOf[UByte]}; separator=", ">)
    var false_data: Array[UByte] = Array(<arruFalseValueAsByteArray:{b|0x<b;format="X2">.asInstanceOf[UByte]}; separator=", ">)
    BitStream_AppendBits(pBitStrm, if <p> then true_data else false_data, <nSize>)
}
>>

Boolean_decode(p, ptr, bEncValIsTrue, nSize, arruTrueValueAsByteArray, arruFalseValueAsByteArray, arrsBits, sErrCode) ::= <<
{
    <if(bEncValIsTrue)>
    var tmp: Array[UByte] = Array(<arruTrueValueAsByteArray:{b|0x<b;format="X2">.asInstanceOf[UByte]}; separator=", ">)
    <else>
    var tmp: Array[UByte] = Array(<arruFalseValueAsByteArray:{b|0x<b;format="X2">.asInstanceOf[UByte]}; separator=", ">)
    <endif>
    BitStream_ReadBitPattern(pBitStrm, tmp, <nSize>) match
        case None =>
            return Left(<sErrCode>)
        case Some(x) => 
            <p> = x
    
    <if(!bEncValIsTrue)><p> = !<p>;<endif>
}
>>

Null_pattern_encode(p, arruNullValueAsByteArray, nSize, arrsBits, sErrCode, bSavePosition) ::= <<
<if(arruNullValueAsByteArray)>
{   // TODO acn:366
    val tmp: Array[Byte] = Array(<arruNullValueAsByteArray:{b|0x<b;format="X2">.asInstanceOf[Byte]}; separator=",">)
    BitStream_AppendBits(pBitStrm, tmp, <nSize>)
}
<endif>
>>


Null_pattern_decode(p, arruNullValueAsByteArray, nSize, arrsBits, sErrCode, bSavePosition) ::= <<
<if(bSavePosition)>
BitStream_ReadBitPattern_ignore_value(pBitStrm, <nSize>) match
    case None => ret = Left(<sErrCode>)
    case Some(i) => ret = Right(i)

<else>
<if(arruNullValueAsByteArray)>
{
    val tmp: Array[Byte] = Array(<arruNullValueAsByteArray:{b|0x<b;format="X2">.asInstanceOf[Byte]}; separator=",">)
    // acn:383
    BitStream_ReadBitPattern(pBitStrm, tmp, <nSize>) match
        case None => ret = Left(<sErrCode>)   
        case Some(b) => 
            if !b then ret = Left(<sErrCode>)
        
    <A(sErrCode)>
}

<endif>

<endif>
>>

Null_pattern2_encode(p, arruNullValueAsByteArray, nSize, arrsBits, sErrCode, bSavePosition) ::= <<
// acn:394
<Null_pattern_encode(p=p, arruNullValueAsByteArray=arruNullValueAsByteArray, nSize=nSize, arrsBits=arrsBits, sErrCode=sErrCode, bSavePosition=bSavePosition)>
>>
Null_pattern2_decode(p, arruNullValueAsByteArray, nSize, arrsBits, sErrCode, bSavePosition) ::= <<
// acn:398
<Null_pattern_decode(p=p, arruNullValueAsByteArray=arruNullValueAsByteArray, nSize=nSize, arrsBits=arrsBits, sErrCode=sErrCode, bSavePosition=bSavePosition)>
>>


Enumerated_item_encode(p, sName, sEnumHolder, nItemIdxOrVal, sIntVal) ::= <<
case <sName> => // acn:404
    <sIntVal> = <nItemIdxOrVal>
>>

Enumerated_item_decode(p, sName, sEnumHolder, nItemIdxOrVal, sIntVal) ::= <<
case <nItemIdxOrVal> => // acn:409
    <p> = <sName>
>>

EnumeratedEncIdx_encode(p, td/*:FE_EnumeratedTypeDefinition*/, arrsItem, sActualCodecFunc, sIntVal) ::= <<
<sActualCodecFunc> // acn:414
>>

EnumeratedEncIdx_decode(p, td/*:FE_EnumeratedTypeDefinition*/, arrsItem, sActualCodecFunc, sIntVal) ::= <<
<sActualCodecFunc> // acn:418
>>

EnumeratedEncValues_encode(p, td/*:FE_EnumeratedTypeDefinition*/, arrsItem, sActualCodecFunc, sErrCode, sFirstItemName, sIntVal) ::= <<
<p> match // acn:431
    <arrsItem; separator="\n">
    case _ =>
        return Left(<sErrCode>)

if ret.isRight then // acn:427
    <sActualCodecFunc>
>>

EnumeratedEncValues_decode(p, td/*:FE_EnumeratedTypeDefinition*/, arrsItem, sActualCodecFunc, sErrCode, sFirstItemName, sIntVal) ::= <<
<sActualCodecFunc>
if ret.isRight then // acn:433
    <sIntVal> match
        <arrsItem; separator="\n">
        case _ =>
            return Left(<sErrCode>)
>>

/* Strings */
Acn_String_Ascii_FixSize_encode(p, sErrCode, nAsn1Max) ::= "Acn_Enc_String_Ascii_FixSize(pBitStrm, <nAsn1Max>, <p>)"
Acn_String_Ascii_FixSize_decode(p, sErrCode, nAsn1Max) ::= <<
Acn_Dec_String_Ascii_FixSize(pBitStrm, <nAsn1Max>) match // acn:443
    case None => 
        return Left(<sErrCode>)
    case Some(x) => 
        <p> = x
>>

Acn_String_Ascii_Null_Teminated_encode(p, sErrCode, nAsn1Max, arruNullBytes) ::= <<
Acn_Enc_String_Ascii_Null_Teminated_mult(pBitStrm, <nAsn1Max>, (byte[]){<arruNullBytes; separator=", ">}, <arruNullBytes.Length>, <p>) // acn:449
>>

Acn_String_Ascii_Null_Teminated_decode(p, sErrCode, nAsn1Max, arruNullBytes) ::= <<
Acn_Dec_String_Ascii_Null_Teminated_mult(pBitStrm, <nAsn1Max>, (byte[]){<arruNullBytes; separator=", ">}, <arruNullBytes.Length>) match // acn
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
>>

Acn_String_Ascii_External_Field_Determinant_encode(p, sErrCode, nAsn1Max, sExtFld) ::= "Acn_Enc_String_Ascii_External_Field_Determinant(pBitStrm, <nAsn1Max>, <p>) // acn:458"
Acn_String_Ascii_External_Field_Determinant_decode(p, sErrCode, nAsn1Max, sExtFld) ::= <<
Acn_Dec_String_Ascii_External_Field_Determinant(pBitStrm, <nAsn1Max>, <sExtFld>) match // acn:460
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
>>

Acn_String_Ascii_Internal_Field_Determinant_encode(p, sErrCode, nAsn1Max, nAsn1Min, nInternalLengthDeterminantSizeInBits) ::= <<
Acn_Enc_String_Ascii_Internal_Field_Determinant(pBitStrm, <nAsn1Max>, <nAsn1Min>, <p>) // acn:466
>>

Acn_String_Ascii_Internal_Field_Determinant_decode(p, sErrCode, nAsn1Max, nAsn1Min, nInternalLengthDeterminantSizeInBits) ::= <<
Acn_Dec_String_Ascii_Internal_Field_Determinant(pBitStrm, <nAsn1Max>, <nAsn1Min>) match // acn:470
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
>>

PrintAlphabet2(arrnCharSet) /*nogen*/ ::= <<
static byte allowedCharSet[] = {<arrnCharSet:{ch|0x<ch;format="X2">}; wrap, anchor, separator=",">} // TODO acn:476
>>

Acn_String_CharIndex_FixSize_encode(p, sErrCode, nAsn1Max, arrnAlphabetAsciiCodes, nCharSetSize, td/*:FE_StringTypeDefinition*/, nCharSize) ::= <<
<PrintAlphabet2(arrnAlphabetAsciiCodes)>
Acn_Enc_String_CharIndex_FixSize(pBitStrm, <nAsn1Max>, allowedCharSet, <nCharSetSize>, <p>) // acn:481
>>

Acn_String_CharIndex_FixSize_decode(p, sErrCode, nAsn1Max, arrnAlphabetAsciiCodes, nCharSetSize, td/*:FE_StringTypeDefinition*/, nCharSize) ::= <<
<PrintAlphabet2(arrnAlphabetAsciiCodes)>
Acn_Dec_String_CharIndex_FixSize(pBitStrm, <nAsn1Max>, allowedCharSet, <nCharSetSize>) match // acn:486
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
>>

Acn_String_CharIndex_External_Field_Determinant_encode(p, sErrCode, nAsn1Max, arrnAlphabetAsciiCodes, nCharSetSize, sExtFld, td/*:FE_StringTypeDefinition*/, nCharSize) ::= <<
<PrintAlphabet2(arrnAlphabetAsciiCodes)>
Acn_Enc_String_CharIndex_External_Field_Determinant(pBitStrm, <nAsn1Max>, allowedCharSet, <nCharSetSize>, <p>) // acn:493
>>

Acn_String_CharIndex_External_Field_Determinant_decode(p, sErrCode, nAsn1Max, arrnAlphabetAsciiCodes, nCharSetSize, sExtFld, td/*:FE_StringTypeDefinition*/, nCharSize) ::= <<
<PrintAlphabet2(arrnAlphabetAsciiCodes)>
Acn_Dec_String_CharIndex_External_Field_Determinant(pBitStrm, <nAsn1Max>, allowedCharSet, <nCharSetSize>, <sExtFld>) match // acn:498
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
>>


Acn_IA5String_CharIndex_External_Field_Determinant_encode(p, sErrCode, nAsn1Max, sExtFld, td/*:FE_StringTypeDefinition*/, nCharSize) ::= <<
Acn_Enc_IA5String_CharIndex_External_Field_Determinant(pBitStrm, <nAsn1Max>, <p>)
>>

Acn_IA5String_CharIndex_External_Field_Determinant_decode(p, sErrCode, nAsn1Max, sExtFld, td/*:FE_StringTypeDefinition*/, nCharSize) ::= <<
Acn_Dec_IA5String_CharIndex_External_Field_Determinant(pBitStrm, <nAsn1Max>, <sExtFld>) match // acn:509
    case None => return Left(<sErrCode>)
    case Some(x) => <p> = x
>>


oct_external_field_encode(p, sAcc, noSizeMin, nSizeMax, sExtFld, nAlignSize, sErrCode) ::= <<
BitStream_EncodeOctetString_no_length(pBitStrm, <p><sAcc>arr, <p><sAcc>nCount.toInt) match // acn:516
    case false => return Left(<sErrCode>)
    case true => ret = Right(0)
>>

oct_external_field_decode(p, sAcc, noSizeMin, nSizeMax, sExtFld, nAlignSize, sErrCode) ::= <<
if (<if(noSizeMin)>(<noSizeMin>\<=<sExtFld>) && <endif>(<sExtFld>\<=<nSizeMax>)) then // acn:522
    <p><sAcc>nCount = <sExtFld>.asInstanceOf[Int]
    BitStream_DecodeOctetString_no_length(pBitStrm, <p><sAcc>nCount.toInt) match
        case None => return Left(<sErrCode>)
        case Some(x) => x.copyToArray(<p><sAcc>arr)
>>

oct_external_field_fix_size_encode(p, sAcc, noSizeMin, nSizeMax, sExtFld, nAlignSize, sErrCode) ::= <<
BitStream_EncodeOctetString_no_length(pBitStrm, <p><sAcc>arr, <nSizeMax>) match // acn:530
    case false => return Left(<sErrCode>)
    case true => ret = Right(0)
>>

oct_external_field_fix_size_decode(p, sAcc, noSizeMin, nSizeMax, sExtFld, nAlignSize, sErrCode) ::= <<
if (<if(noSizeMin)>(<noSizeMin>\<=<sExtFld>) && <endif>(<sExtFld>\<=<nSizeMax>)) then // acn:536
    BitStream_DecodeOctetString_no_length(pBitStrm, <nSizeMax>) match 
        case None => return Left(<sErrCode>)
        case Some(x) => <p><sAcc>arr = x
>>


sqf_external_field_encode(p, sAcc, i, sInternalItem, noSizeMin, nSizeMax, sExtFld, nAlignSize, sErrCode, nIntItemMinSize, nIntItemMaxSize) ::= <<
<loopFixedItem(i=i, sInternalItem=sInternalItem, fixedSize=[p, sAcc, "nCount"])>
>>

sqf_external_field_decode(p, sAcc, i, sInternalItem, noSizeMin, nSizeMax, sExtFld, nAlignSize, sErrCode, nIntItemMinSize, nIntItemMaxSize) ::= <<
if (<if(noSizeMin)>(<noSizeMin>\<=<sExtFld>) && <endif>(<sExtFld>\<=<nSizeMax>)) then // acn:548
    <p><sAcc>nCount = <sExtFld>.asInstanceOf[Int]
    <loopFixedItem(i=i, sInternalItem=sInternalItem, fixedSize=[p,sAcc, "nCount"])>
>>

sqf_external_field_fix_size_encode(p, sAcc, i, sInternalItem, noSizeMin, nSizeMax, sExtFld, nAlignSize, sErrCode, nIntItemMinSize, nIntItemMaxSize) ::= <<
<loopFixedItem(i=i, sInternalItem=sInternalItem, fixedSize=[nSizeMax])>
>>

sqf_external_field_fix_size_decode(p, sAcc, i, sInternalItem, noSizeMin, nSizeMax, sExtFld, nAlignSize, sErrCode, nIntItemMinSize, nIntItemMaxSize) ::= <<
if (<if(noSizeMin)>(<noSizeMin>\<=<sExtFld>) && <endif>(<sExtFld>\<=<nSizeMax>)) then // acn:558
    <loopFixedItem(i=i, sInternalItem=sInternalItem, fixedSize=[nSizeMax])>
>>

oct_sqf_null_terminated_encode(p, sAcc, i, sInternalItem, noSizeMin, nSizeMax, arruNullBytes, nBitPatternLength, sErrCode, nIntItemMinSize, nIntItemMaxSize) ::= <<
<loopFixedItem(i=i, sInternalItem=sInternalItem, fixedSize=[p, sAcc, "nCount"])>
BitStream_AppendBits(pBitStrm, (byte[]){<arruNullBytes; separator=", ">}, <nBitPatternLength>) // TODO acn:564
>>

oct_sqf_null_terminated_decode(p, sAcc, i, sInternalItem, noSizeMin, nSizeMax, arruNullBytes, nBitPatternLength, sErrCode, nIntItemMinSize, nIntItemMaxSize) ::= <<
<i> = 0
ret = Right(0) // acn:569
while ret.isRight && <i> \< <nSizeMax> && ((checkBitPatternPresentResult = BitStream_checkBitPatternPresent(pBitStrm, (byte[]){<arruNullBytes; separator=", ">}, <nBitPatternLength>)) == 1)) do
    <sInternalItem>
    <i> += 1

if ret.isRight && (<i> == <nSizeMax>) && (checkBitPatternPresentResult == 1) then // TODO acn:574
    checkBitPatternPresentResult = BitStream_checkBitPatternPresent(pBitStrm, (byte[]){<arruNullBytes; separator=", ">}, <nBitPatternLength>)

if (ret && (checkBitPatternPresentResult == 0)) {
    ret = FALSE;			/*COVERAGE_IGNORE*/
    *pErrCode = <sErrCode>;	/*COVERAGE_IGNORE*/
} else if (ret && (checkBitPatternPresentResult == 2)) {
    <p><sAcc>nCount = <i>;
    ret = true;
    *pErrCode = 0;
}
>>

bit_string_external_field_encode(p, sErrCode, sAcc, noSizeMin, nSizeMax, sExtFld) ::= <<
BitStream_AppendBits(pBitStrm, <p><sAcc>arr, <p><sAcc>nCount)
>>

bit_string_external_field_decode(p, sErrCode, sAcc, noSizeMin, nSizeMax, sExtFld) ::= <<
if <if(noSizeMin)>(<noSizeMin>\<=<sExtFld>) && <endif>(<sExtFld>\<=<nSizeMax>) then
    <p><sAcc>nCount = <sExtFld>.asInstanceOf[Int]
    BitStream_ReadBits(pBitStrm, <p><sAcc>nCount) match
        case None => return Left(<sErrCode>)
        case Some(arr) => 
            <p><sAcc>arr = arr
            ret = Right(0)
>>

bit_string_external_field_fixed_size_encode(p, sErrCode, sAcc, noSizeMin, nSizeMax, sExtFld) ::= <<
BitStream_AppendBits(pBitStrm, <p><sAcc>arr, <nSizeMax>) // acn:602
>>

bit_string_external_field_fixed_size_decode(p, sErrCode, sAcc, noSizeMin, nSizeMax, sExtFld) ::= <<
if <if(noSizeMin)>(<noSizeMin>\<=<sExtFld>) && <endif>(<sExtFld>\<=<nSizeMax>) then // acn:606
    BitStream_ReadBits(pBitStrm, <nSizeMax>) match
        case None => return Left(<sErrCode>)
        case Some(arr) => 
            <p><sAcc>arr = arr
            ret = Right(0)
>>

bit_string_null_terminated_encode(p, sErrCode, sAcc, i, noSizeMin, nSizeMax, arruNullBytes, nBitPatternLength) ::= <<
BitStream_AppendBits(pBitStrm, <p><sAcc>arr, <p><sAcc>nCount)
BitStream_AppendBits(pBitStrm, (byte[]){<arruNullBytes; separator=", ">}, <nBitPatternLength>) // TODO acn:616
>>

bit_string_null_terminated_decode(p, sErrCode, sAcc, i, noSizeMin, nSizeMax, arruNullBytes, nBitPatternLength) ::= <<
// TODO acn:620 - wrong ret value? reads bits untill 0 termination, but only length is returned, not the data
BitStream_ReadBits_nullterminated(pBitStrm, (byte[]){<arruNullBytes; separator=", ">}, <nBitPatternLength>, <p><sAcc>arr, <nSizeMax>) match
    case None => 
        return Left(<sErrCode>)
    case Some(x) => 
        <p><sAcc>nCount = x
>>

RefTypeParam_tmpVar(sName, sTypeDecl) ::= "<sTypeDecl> <sName> /* acn:628 */"

ReferenceType1_encode(p, sName, bAcnEncodeFuncRequiresResult, arrsArgs, arrsLocalPrms) ::= <<
<arrsLocalPrms, arrsArgs: {lp,arg|<if(arg)><lp> = <arg>;// 3031<endif>}; separator="\n">
ret = <sName>_ACN_Encode(<p>, pBitStrm, pErrCode, FALSE<if(arrsArgs)>, <arrsLocalPrms; separator=", "><endif>) // acn:632
>>

ReferenceType1_decode(p, sName, bAcnEncodeFuncRequiresResult, arrsArgs, arrsLocalPrms) ::= <<
<arrsLocalPrms, arrsArgs: {lp,arg|<if(arg)><lp> = <arg>; // 3030<endif>}; separator="\n">
ret = <sName>_ACN_Decode(<p>, pBitStrm, pErrCode<if(arrsArgs)>, <arrsLocalPrms; separator=", "><endif>) // acn:637
>>


/* SEQUENCE*/


sequence_presense_optChild_encode(p, sAcc, sChName, sErrCode) ::= "BitStream_AppendBit(pBitStrm,<p><sAcc>exist.<sChName>)"
sequence_presense_optChild_decode(p, sAcc, sChName, sErrCode) ::= <<
BitStream_ReadBit(pBitStrm) match
    case Some(bit) => 
        <p><sAcc>exist.<sChName> = bit
    case None => 
        return Left(<sErrCode>)
>>

sequence_presense_optChild_pres_acn_expression_encode(p, sAcc, sChName, sAcnExpression, sErrCode) ::= <<
<p><sAcc>exist.<sChName> == <sAcnExpression> match // acn:654
    case false => 
        return Left(<sErrCode>)
    case true =>
        ret = Right(0)
>>
sequence_presense_optChild_pres_acn_expression_decode(p, sAcc, sChName, sAcnExpression, sErrCode) ::= <<
<p><sAcc>exist.<sChName> = <sAcnExpression> // acn:661
>>

sequence_presense_optChild_pres_bool_encode(p, sAcc, sChName, sExtFldName) ::= ""
sequence_presense_optChild_pres_bool_decode(p, sAcc, sChName, sExtFldName) ::= <<
<p><sAcc>exist.<sChName> = <sExtFldName> // acn:666
>>

sequence_presense_optChild_pres_int_encode(p, sAcc, sChName, sExtFldName, nIntVal) ::= ""
sequence_presense_optChild_pres_int_decode(p, sAcc, sChName, sExtFldName, nIntVal) ::= <<
<p><sAcc>exist.<sChName> = <sExtFldName> == <nIntVal> // acn:671
>>

sequence_presense_optChild_pres_str_encode(p, sAcc, sChName, sExtFldName, sVal) ::= ""
sequence_presense_optChild_pres_str_decode(p, sAcc, sChName, sExtFldName, sVal) ::= <<
<p><sAcc>exist.<sChName> = <sExtFldName> == "<sVal>" // acn:676
>>

sequence_save_bitStream_start_encode(sBitStreamPositionsLocalVar) ::=<<
<sBitStreamPositionsLocalVar> = pBitStrm // save the initial position of the bit stream at // acn:680
>>

sequence_save_bitStream_start_decode(sBitStreamPositionsLocalVar) ::=<<
ret = Right(0) // acn:684
<sBitStreamPositionsLocalVar> = pBitStrm // save the initial position of the bit stream
>>

sequence_save_bitstream_encode(sBitStreamPositionsLocalVar, sChName) ::=<<
<sBitStreamPositionsLocalVar>.<sChName> = pBitStrm // save position of the bit stream // acn:689
>>

sequence_save_bitstream_decode(sBitStreamPositionsLocalVar, sChName) ::=<<
<sBitStreamPositionsLocalVar>.<sChName> = pBitStrm // save position of the bit stream // acn:693
>>

sequence_acn_child_encode(sChName, sChildContent, sErrCode, soSaveBitStrmPosStatement) ::= <<
/* Encode <sChName> acn:697 */
if <sChName>_is_initialized then
    ret = Right(0)
    <soSaveBitStrmPosStatement>
    <sChildContent>
else 
    return Left(<sErrCode>)
>>

sequence_acn_child_decode(sChName, sChildContent, sErrCode, soSaveBitStrmPosStatement) ::= <<
/* Decode <sChName> acn:707 */ 
<soSaveBitStrmPosStatement>
<sChildContent>
>>

sequence_mandatory_child_encode(sChName, sChildContent, soSaveBitStrmPosStatement) ::= <<
/* Encode <sChName> acn:713 */
<soSaveBitStrmPosStatement>
<sChildContent>
>>

sequence_mandatory_child_decode(sChName, sChildContent, soSaveBitStrmPosStatement) ::= <<
/* Decode <sChName> acn:718 */
<soSaveBitStrmPosStatement>
<sChildContent>
>>

sequence_always_present_child_encode(p, sAcc, sChName, sChildContent, soSaveBitStrmPosStatement) ::= <<
/* Encode <sChName> acn:725 */
/* marked as ALWAYS PRESENT, so do not look in exist */
<soSaveBitStrmPosStatement>
<sChildContent>
>>

sequence_always_present_child_decode(p, sAcc, sChName, sChildContent, soSaveBitStrmPosStatement) ::= <<
/* Decode <sChName> acn:732 */
/* marked as ALWAYS PRESENT */
<p><sAcc>exist.<sChName> = true
<soSaveBitStrmPosStatement>
<sChildContent>
>>

sequence_always_absent_child_encode(p, sAcc, sChName, sChildContent, soSaveBitStrmPosStatement) ::= <<
/* Encode <sChName> acn:740 */
/* marked as ALWAYS ABSENT, so do not encode anything */
<soSaveBitStrmPosStatement>
>>

sequence_always_absent_child_decode(p, sAcc, sChName, sChildContent, soSaveBitStrmPosStatement) ::= <<
/* Decode <sChName> acn:746 */
/* marked as ALWAYS ABSENT, so do not decode anything */
<soSaveBitStrmPosStatement>
<p><sAcc>exist.<sChName> = false
>>

sequence_optional_child_encode(p, sAcc, sChName, sChildContent, soSaveBitStrmPosStatement) ::= <<
/* Encode <sChName> acn:753 */
<soSaveBitStrmPosStatement>
if <p><sAcc>exist.<sChName> then
    <sChildContent>
>>

sequence_optional_child_decode(p, sAcc, sChName, sChildContent, soSaveBitStrmPosStatement) ::= <<
/* Decode <sChName> acn:760 */
<soSaveBitStrmPosStatement>
if <p><sAcc>exist.<sChName> then
    <sChildContent>
>>

sequence_optional_always_present_child_encode(p, sAcc, sChName, sChildContent, soSaveBitStrmPosStatement) ::= <<
/* Encode <sChName> acn:767 */
<soSaveBitStrmPosStatement>
<sChildContent>
>>

sequence_optional_always_present_child_decode(p, sAcc, sChName, sChildContent, soSaveBitStrmPosStatement) ::= <<
/* Decode <sChName> (always present) acn:773 */
<soSaveBitStrmPosStatement>
<p><sAcc>exist.<sChName> = true
<sChildContent>
>>

sequence_default_child_encode(p, sAcc, sChName, sChildContent, sInitWithDefaultValue, soSaveBitStrmPosStatement) ::= <<
<soSaveBitStrmPosStatement>
<sequence_optional_child_encode(p=p, sAcc=sAcc, sChName=sChName, sChildContent=sChildContent, soSaveBitStrmPosStatement=soSaveBitStrmPosStatement)>
>>

sequence_default_child_decode(p, sAcc, sChName, sChildContent, sInitWithDefaultValue, soSaveBitStrmPosStatement) ::= <<
/* Decode <sChName>  acn:785 */
<soSaveBitStrmPosStatement>
if <p><sAcc>exist.<sChName> then
    <sChildContent>
else
    <sInitWithDefaultValue>
>>

sequence_call_post_encoding_function(p, sFncName, sBitStreamStartPos, sBitStreamPositionsNullPos) ::= <<
<sFncName>(<p>, &<sBitStreamStartPos>, &<sBitStreamPositionsNullPos>, pBitStrm) // acn:794
>>

sequence_call_post_decoding_validator(p, sFncName, sBitStreamStartPos, sBitStreamPositionsNullPos) ::= <<
ret = <sFncName>(<p>, &<sBitStreamStartPos>, &<sBitStreamPositionsNullPos>, pBitStrm, pErrCode) // acn:798
>>

/* SEQUENCE END */


/* Choice like uper */
ChoiceChildAlwaysAbsent_encode(p, sAcc, sChildID, nChildIndex, sErrorCodeName) ::= <<
case <sChildID> => // acn:806
    return Left(<sErrorCodeName>)
>>

ChoiceChildAlwaysAbsent_decode(p, sAcc, sChildID, nChildIndex, sErrorCodeName) ::= <<
case <nChildIndex> => // acn:811
    return Left(<sErrorCodeName>)
>>

ChoiceChild_encode(p, sAcc, sChildID, nChildIndex, nIndexSizeInBits, nLastItemIndex, sChildContent, sChildName, sChildTypeDef, sChoiceTypeName, sChildInitExpr) ::= <<
case <sChildID>(<sChildName>) => // acn:816
    BitStream_EncodeConstraintWholeNumber(pBitStrm, <nChildIndex>, 0, <nLastItemIndex>)
    <sChildContent>
>>

ChoiceChild_decode(p, sAcc, sChildID, nChildIndex, nIndexSizeInBits, nLastItemIndex, sChildContent, sChildName, sChildTypeDef, sChoiceTypeName, sChildInitExpr) ::= <<
case <nChildIndex> => // acn:824
    var <sChildName>: <sChildTypeDef> = <sChildInitExpr>
    <sChildContent>
    <p> = <sChildID>(<sChildName>)
>>

Choice_encode(p, sAcc, arrsChildren, nLastItemIndex, sChoiceIndexName, td/*:FE_ChoiceTypeDefinition*/, nIndexSizeInBits, sErrCode) ::= <<
<p> match // acn:828
    <arrsChildren: {ch|<ch>}; separator="\n">
    case _ =>
        return Left(<sErrCode>)
>>

Choice_decode(p, sAcc, arrsChildren, nLastItemIndex, sChoiceIndexName, td/*:FE_ChoiceTypeDefinition*/, nIndexSizeInBits, sErrCode) ::= <<
BitStream_DecodeConstraintWholeNumber(pBitStrm, 0, <nLastItemIndex>) match // acn:835
    case None => 
        return Left(<sErrCode>)
    case Some(x) =>
        <sChoiceIndexName> = x.asInstanceOf[Int]
        
<sChoiceIndexName> match
    <arrsChildren: {ch|<ch>}; separator="\n">
    case _ =>
        return Left(<sErrCode>)
>>

/* Choice with presense determinants */

ChoiceChild_preWhen_encode(p, sAcc, sChildID, sChildBody, arrsConditions, bFirst, sChildName, sChildTypeDef, sChoiceTypeName, sChildInitExpr) ::= <<
case <sChildID>(<sChildName>) => // acn:850
    <sChildBody>
>>

ChoiceChild_preWhen_bool_condition(sExtFld) ::= "<sExtFld> /* acn:854 */"
ChoiceChild_preWhen_int_condition(sExtFld, nVal) ::= "(<sExtFld> == <nVal>) /* acn:855 */"
ChoiceChild_preWhen_str_condition(sExtFld, sVal, arrsNullChars) ::= "(<sExtFld>.sameElements(\"<sVal>\".getBytes)) /* acn:856 */"

ChoiceChild_preWhen_decode(p, sAcc, sChildID, sChildBody, arrsConditions, bFirst, sChildName, sChildTypeDef, sChoiceTypeName, sChildInitExpr) ::= <<
<if(!bFirst)>else <endif>if (<arrsConditions; separator=" && ">) {
    var <sChildName>: <sChildTypeDef> = <sChildInitExpr> // acn:873
    <sChildBody>
    <p> = <sChildID>(<sChildName>)
}
>>

Choice_preWhen_encode(p, sAcc, arrsChildren, sErrCode) ::= <<
<p> match // acn:873
    <arrsChildren; separator="\n">
    case _ =>
        return Left(<sErrCode>)
>>

Choice_preWhen_decode(p, sAcc, arrsChildren, sErrCode) ::= <<
<arrsChildren; separator="\n">
else // acn:882, no if case?
    return Left(<sErrCode>)
>>

/* Choice with Enum determinant */
ChoiceChild_Enum_encode(p, sAcc, sEnmName, sChildID, sChildBody, sChildName, sChildTypeDef, sChoiceTypeName, sChildInitExpr) ::= <<
case <sChildID>(<sChildName>) => // acn:888
    <sChildBody>
>>

ChoiceChild_Enum_decode(p, sAcc, sEnmName, sChildID, sChildBody, sChildName, sChildTypeDef, sChoiceTypeName, sChildInitExpr) ::= <<
case <sEnmName> => // acn:893
    var <sChildName>: <sChildTypeDef> = <sChildInitExpr>
    <sChildBody>
    <p> = <sChildID>(<sChildName>)
>>

Choice_Enum_encode(p, sAcc, arrsChildren, sEnmExtFld, sErrCode) ::= <<
<p> match // acn:899
    <arrsChildren; separator="\n">
    case _ =>
        ret = Left(ERR_INVALID_ENUM_VALUE)
>>

Choice_Enum_decode(p, sAcc, arrsChildren, sEnmExtFld, sErrCode) ::= <<
<sEnmExtFld> match // acn:906
    <arrsChildren; separator="\n">
    case _ =>
        ret = Left(ERR_INVALID_ENUM_VALUE)
>>

/* Updates */
SizeDependency(v, sCount, nMin, nMax, bCheckRange, sTypedefName) ::= <<
<v>_is_initialized = true // acn:908
<v> = <sCount>
>>

SizeDependencyFixedSize(v, nFixedSize) ::= <<
<v>_is_initialized = true // acn:913
<v> = <nFixedSize>
>>

ChoiceDependencyEnum_Item(v, sChildCID, sChildCIDHolder, sEnumCName) ::= <<
case <sChildCIDHolder>.<sChildCID>(x) => // acn:918
    <v>_is_initialized = true
    <v> = <sEnumCName>
>>

ChoiceDependencyEnum(sChPath, sAcc, arrsChoiceEnumItems) ::= <<
<sChPath> match // acn:924
    <arrsChoiceEnumItems; separator="\n">
    case _ =>
        return Left(ERR_INVALID_ENUM_VALUE) 
>>

PresenceDependency(v, sSeqPath, sAcc, sChildName) ::= <<
<v>_is_initialized = true // acn:931
<v> = (<sSeqPath><sAcc>exist.<sChildName>)
>>

ChoiceDependencyIntPres_child(v, sChildNamePrese, nChildRetVal) ::= <<
case _: <sChildNamePrese> => // acn:936
    <v>_is_initialized = true
    <v> = <nChildRetVal>
>>

ChoiceDependencyStrPres_child(v, sChildNamePrese, sChildRetVal, arrsNullChars) ::= <<
case <sChildNamePrese> => // acn:942
    <v>_is_initialized = true
    <v> = "<sChildRetVal>".getBytes
>>

ChoiceDependencyPres(sChPath, sAcc, arrsChoiceItems) ::= <<
<sChPath> match // acn:948
    <arrsChoiceItems; separator="\n">
    case _ =>
        return Left(951)
>>

MultiAcnUpdate_checkEqual_pri0(p1,p2) ::= "(<p1> == <p2>) // acn:954"
MultiAcnUpdate_checkEqual_str0(p1,p2) ::= "(<p1> == <p2>) // acn:955"

MultiAcnUpdate_get_first_init_value_pri(sV0, sVi, bIsFirst) ::= <<
<if(!bIsFirst)>else <endif>if <sVi>_is_initialized then // acn:966
    <sV0> = <sVi>
>>

MultiAcnUpdate_get_first_init_value_str(sV0, sVi, bIsFirst) ::= <<
<if(!bIsFirst)>else <endif>if <sVi>_is_initialized then // acn:972
    <sV0> = <sVi>
>>

MultiAcnUpdate_checkEqual_pri(sV0, sVi) ::= "((<sVi>_is_initialized && <sV0> == <sVi>) || !<sVi>_is_initialized)"
MultiAcnUpdate_checkEqual_str(sV0, sVi) ::= "((<sVi>_is_initialized && <sV0> == <sVi>) || !<sVi>_is_initialized)"


MultiAcnUpdate(v, sV0, sErrCode, arrsLocalDeclarations, arrsLocalUpdateStatements, arrsGetFirstIntValue, arrsLocalCheckEquality) ::= <<
{
    <arrsLocalDeclarations; separator="\n">
    
    <arrsLocalUpdateStatements; separator="\n">
    
    if ret.isRight then // acn:978
    
        <arrsGetFirstIntValue; separator="\n"> 
        else // acn:988
            return Left(<sErrCode>)
        
        if ret.isRight then
            <v>_is_initialized = true
}
>>


checkAccessPath(arrsCheckPaths, sUpdateStatement) ::= <<
if <arrsCheckPaths; separator=" && "> then // acn:992
    <sUpdateStatement>
>>


SizeDependency_oct_str_containing(p, sFuncName, sReqBytesForUperEncoding, v, bIsOctet, sComment) ::= <<
{ // acn:998
    /*first encode containing type to a temporary bitstream. That's the only way to learn in advance the size of the encoding octet string*/
    val pBitStrm_save: BitStream = pBitStrm
    pBitStrm = BitStream_Init(arr.length)
    <sComment>
    pBitStrm = pBitStrm_save
}
if ret.isRight then
    <v> = <if(bIsOctet)>bitStrm.currentBit == 0 ? bitStrm.currentByte : (bitStrm.currentByte + 1)<else>bitStrm.currentByte*8+bitStrm.currentBit<endif>;
    <v>_is_initialized = true

>>

octet_string_containing_ext_field_func_encode(p, sFuncName, sReqBytesForUperEncoding, sExtField, sErrCode, soInner) ::= <<
BitStream_EncodeOctetString_no_length(pBitStrm, arr, <sExtField>.asInstanceOf[Int]) match // acn:1012
    case false => 
        return Left(<sErrCode>)
    case true =>
        ret = Right(0)
>>

octet_string_containing_ext_field_func_decode(p, sFuncName, sReqBytesForUperEncoding, sExtField, sErrCode, soInner) ::= <<
/*open new scope to declare some variables*/
{
    /*decode to a temporary bitstream acn:1022*/
    val pBitStrm_save: BitStream = pBitStrm
    val bitStrm: BitStream = BitStream_Init(<sReqBytesForUperEncoding>)
    
    if <sExtField>.asInstanceOf[Int] \<= <sReqBytesForUperEncoding> then
        BitStream_DecodeOctetString_no_length(pBitStrm, <sExtField>.asInstanceOf[Int]) match
            case None => 
                return Left(<pErrCode>)
            case Some(arr) =>
                bitStrm.buf = arr

        pBitStrm = bitStrm
        <soInner>
        pBitStrm = pBitStrm_save;
}
>>

bit_string_containing_ext_field_func_encode(p, sFuncName, sReqBytesForUperEncoding, sReqBitsForUperEncoding, sExtField, sErrCode) ::= <<
BitStream_AppendBits(pBitStrm, arr, <sExtField>.asInstanceOf[Int])
>>

bit_string_containing_ext_field_func_decode(p, sFuncName, sReqBytesForUperEncoding, sReqBitsForUperEncoding, sExtField, sErrCode) ::= <<
/*open new scope to declare some variables*/
{
    /*decode to a temporary bitstream acn:1046*/
    val bitStrm: BitStream = BitStream_Init(<sReqBytesForUperEncoding>)
    if <sExtField>.asInstanceOf[Int] \<= <sReqBitsForUperEncoding> then
        BitStream_ReadBits(pBitStrm, (int)<sExtField>) match
            case None => 
                return Left(<pErrCode>)
            case Some(arr) =>
                bitStrm.buf = arr

        ret = <sFuncName>(<p>, bitStrm)
}
>>

rtlModuleName() ::= ""
sparkAnnotations_encode(sTypeDefName) ::= ""
sparkAnnotations_decode(sTypeDefName) ::= ""

octet_string_containing_func_encode(p, sFuncName, sReqBytesForAcnEncoding, nBits, nMinSize, nMaxSize, bFixedSize) ::= <<
/*open new scope to declare some variables*/
{
    /*encode to a temporary bitstream acn:1066*/ 
    val bitStrm: BitStream = BitStream_Init(<sReqBytesForAcnEncoding>)
    ret = <sFuncName>(<p>, bitStrm, false) // TODO check if correct call acn:1068
    
    if ret.isRight then
        int nCount = bitStrm.currentBit == 0 ? bitStrm.currentByte : (bitStrm.currentByte + 1)
        <if(bFixedSize)>
        BitStream_EncodeOctetString_no_length(pBitStrm, bitStrm.buf, nCount) match
            case false =>
                return Left(pErrCode)
            case true =>
                ret = Right(0)
                
        <else>
        BitStream_EncodeConstraintWholeNumber(pBitStrm, nCount, <nMinSize>, <nMaxSize>)
        BitStream_EncodeOctetString_no_length(pBitStrm, bitStrm.buf, nCount) match
            case false =>
                return Left(pErrCode)
            case true =>
                ret = Right(0)

        <endif> 
}
>>

octet_string_containing_func_decode(p, sFuncName, sReqBytesForAcnEncoding, nBits, nMinSize, nMaxSize, bFixedSize) ::= <<
/*open new scope to declare some variables*/
{	
    /*decode to a temporary bitstream acn:1094*/ 
    val bitStrm: BitStream = BitStream_Init(<sReqBytesForAcnEncoding>)

    <if(bFixedSize)>
    BitStream_DecodeOctetString_no_length(pBitStrm, <nMinSize>) match
        case None =>
            return Left(pErrCode)
        case Some(arr) =>
            bitStrm.buf = arr

    <else>
    var nCount: Int = 0
    BitStream_DecodeConstraintWholeNumber(pBitStrm, <nMinSize>, <nMaxSize>) match
        case None =>
            return Left(pErrCode)
        case Some(x) =>
            nCount = x

    if ret.isRight then
        BitStream_DecodeOctetString_no_length(pBitStrm, nCount.asInstanceOf[Int])
            case None =>
                return Left(pErrCode)
            case Some(arr) =>
                bitStrm.buf = arr

    <endif>
    if ret.isRight then
        ret = <sFuncName>(<p>, &bitStrm) // TODO check if correct call acn:1121
}
>>

bit_string_containing_func_encode(p, sFuncName, sReqBytesForAcnEncoding, sReqBitsForUperEncoding, nBits, nMinSize, nMaxSize, bFixedSize) ::= <<
/*open new scope to declare some variables*/
{
    /*encode to a temporary bitstream acn:1128*/
    val bitStrm: BitStream = BitStream_Init(<sReqBytesForAcnEncoding>)

    ret = <sFuncName>(<p>, bitStrm, false) // TODO check if call is correct asn:1131
    if ret.isRight then
        val nCount: Int = bitStrm.currentByte*8 + bitStrm.currentBit;
        <if(bFixedSize)>
        BitStream_AppendBits(pBitStrm, bitStrm.buf, nCount);

        <else>
        BitStream_EncodeConstraintWholeNumber(pBitStrm, nCount, <nMinSize>, <nMaxSize>)
        BitStream_AppendBits(pBitStrm, bitStrm.buf, nCount)

        <endif>
}
>>

bit_string_containing_func_decode(p, sFuncName, sReqBytesForAcnEncoding, sReqBitsForUperEncoding, nBits, nMinSize, nMaxSize, bFixedSize) ::= <<
/*open new scope to declare some variables*/
{	
    /*decode to a temporary bitstream acn:1148*/
    val bitStrm: BitStream = BitStream_Init(<sReqBytesForAcnEncoding>)
    
    <if(bFixedSize)>
    BitStream_ReadBits(pBitStrm, <nMinSize>) match
        case None =>
            return Left(pErrCode)
        case Some(arr) =>
            bitStrm.buf = arr

    if ret.isRight then
        ret = <sFuncName>(<p>, bitStrm) // TODO check if call is right

    <else>
    var nCount: Int = 0
    BitStream_DecodeConstraintWholeNumber(pBitStrm, <nMinSize>, <nMaxSize>) match
        case None =>
            return Left(pErrCode)
        case Some(x) =>
            nCount = x
            ret = Right(0)

    BitStream_ReadBits(pBitStrm, nCount) match
        case None =>
            return Left(pErrCode)
        case Some(arr) =>
            bitStrm.buf = arr
            ret = Right(0)

    ret = <sFuncName>(<p>, bitStrm) // TODO check if call is right acn:1178

    <endif>
}
>>
